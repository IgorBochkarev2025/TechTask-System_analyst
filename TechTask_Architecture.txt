[Источники событий]
    → [Сервис событий (Event Service)]
        → [Брокер сообщений (Kafka/RabbitMQ)]
            → [Сервис PUSH‑уведомлений (Push Service)]
                → [Firebase Cloud Messaging (FCM) / Apple Push Notification Service (APNs)]
                    → [Мобильное приложение пользователя]

[Админ‑панель]
    → [Сервис PUSH‑уведомлений (Push Service)]
        → [FCM / APNs]
            → [Мобильное приложение]

[Сервис PUSH‑уведомлений]
    ↔ [База данных шаблонов и статусов]
    ↔ [Сервис аутентификации (Auth Service)]


Автоматические PUSH (на основе событий)

Микросервис генерирует событие (например, «заказ отменён»).

Event Service отправляет в брокер.

Push Service получает событие, формирует уведомление, запрашивает device_token у Auth Service.

Push Service отправляет в FCM/APNs.

Пользователь получает PUSH.

Ручные PUSH (из админ‑панели)

Администратор создаёт рассылку в админ‑панели.

Push Service получает запрос, выбирает пользователей по фильтрам (например, «все, кто добавил товар в корзину»).

Для каждого пользователя: формирует текст, получает device_token, отправляет в FCM/APNs.

Пользователи получают PUSH.

Ключевые требования к архитектуре
Отказоустойчивость:

Брокер сообщений гарантирует доставку при сбоях.

Push Service повторяет отправку при ошибках FCM/APNs.

Масштабируемость:

Несколько инстансов Push Service могут потреблять сообщения из брокера.

FCM/APNs обрабатывают массовые рассылки.

Персонализация:

Шаблоны поддерживают переменные ({{имя}}, {{название_товара}}).

Аналитика:

Логирование статусов позволяет отслеживать доставку и клики.

Безопасность:

device_token передаётся только через защищённые каналы.

Аутентификация запросов между сервисами (JWT/OAuth).

Варианты развития
Добавить A/B‑тестирование текстов PUSH.

Интегрировать с сервисами аналитики (например, подсчёт конверсии из PUSH).

Поддерживать Rich Notifications (изображения, кнопки внутри PUSH).
